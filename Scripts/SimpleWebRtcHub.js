var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SimpleWebRtcHub = (function (_super) {
    __extends(SimpleWebRtcHub, _super);
    function SimpleWebRtcHub() {
        var _this = _super.call(this) || this;
        _this.hubName = 'voiceChatHub';
        if (!$.connection[_this.hubName]) {
            // no autogenerated proxy, create our own
            _this.hubProxy = $.connection.hub.createHubProxy(_this.hubName);
        }
        else {
            _this.hubProxy = $.connection[_this.hubName];
        }
        return _this;
    }
    SimpleWebRtcHub.prototype.getSessionid = function () {
        return $.connection.hub.id;
    };
    SimpleWebRtcHub.prototype.disconnect = function () {
        this.emit("leave");
    };
    /// <summary>
    /// Subscribe to server-initiated invokes
    /// </summary>
    SimpleWebRtcHub.prototype.on = function (hubAction, callback) {
        var _this = this;
        // normalize to PascalCase for logging and due to the fact that signalR itself is case insensitive
        hubAction = hubAction.charAt(0).toUpperCase() + hubAction.substr(1, hubAction.length - 1);
        // handlers are invoking in processServerInvoke function, so we need just one handler at hubProxy
        if (!this.events[hubAction]) {
            this.hubProxy.on(hubAction, function () {
                var hubArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    hubArgs[_i] = arguments[_i];
                }
                _this.processServerInvoke(hubAction, hubArgs);
            });
        }
        _super.prototype.on.call(this, hubAction, callback);
        return this;
    };
    SimpleWebRtcHub.prototype.processServerInvoke = function (hubAction, hubArgs) {
        var handlers = this.events[hubAction];
        if (!handlers || !handlers.length)
            return;
        for (var idx = 0; idx < handlers.length; idx++) {
            var handler = handler[idx];
            try {
                handler.apply(this, hubArgs);
            }
            catch (e) {
                var errorData = e && { errorMessage: e["message"], stack: e["stack"] };
                console.error(hubAction + " failed", errorData);
            }
        }
    };
    /// <summary>
    /// Invoke method on the server.
    /// In case last argument is a function, it would be used as a callback (err, res) => void. But it's better to use promise.
    /// </summary>
    SimpleWebRtcHub.prototype.emit = function (message) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var callback = function () { };
        if (args.length) {
            // if we have the callback fn passed to emit call, splice it from args and fire it on done
            var hasCallback = typeof args[args.length - 1] == "function";
            if (hasCallback) {
                callback = args[args.length - 1];
                args.splice(args.length - 1);
            }
        }
        // get message back to args
        args.unshift(message);
        return this.hubProxy.invoke.apply(this.hubProxy, args)
            .done(function (result) {
            callback.apply(_this, [null, result]);
        }).fail(function (err) {
            // callback is in standart js-notation function(err: Error, result?: any)
            callback.apply(_this, [err]);
        });
    };
    SimpleWebRtcHub.prototype.off = function (event, callback) {
        var _this = this;
        var unbind = function (ev, cb) {
            _super.prototype.off.call(_this, ev, cb);
            // if there's no event handlers left, unbind from hub proxy
            if (!_this.events[ev])
                _this.hubProxy.off(ev, undefined); // wrong d.ts, see jquery.signalR-2.2.0.js:2645, we can call hubProxy.off without specifying callback
        };
        if (event) {
            unbind(event, callback);
            return;
        }
        $.each(this.events, function (ev, cb) { unbind(ev); });
    };
    return SimpleWebRtcHub;
}(EventEmitter));
//# sourceMappingURL=SimpleWebRtcHub.js.map